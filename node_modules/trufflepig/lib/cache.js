/*       */

             
        
              
            
                    
                     

const { readFile } = require('fs');
const { promisify } = require('util');
const EventEmitter = require('events');
const chokidar = require('chokidar');

const identity                    = i => i;

class TrufflePigCache extends EventEmitter {
                
                
                                
  constructor(paths                        , { transform }            = {}) {
    super();
    this._cache = new Map();
    this._watcher = chokidar.watch(paths, {
      awaitWriteFinish: true,
      persistent: true,
    });
    this._watcher
      .on('add', async path => this.add(path))
      .on('change', async path => this.change(path))
      .on('error', error => this.emit('error', error))
      .on('unlink', path => this.remove(path))
      .on('ready', () => {
        const interval = setInterval(() => {
          if (this._cache.size) {
            clearInterval(interval);
            this.emit('ready');
          }
        }, 1000);
      });
    this._transform = transform || identity;
  }
  async _readFile(path        )                       {
    let contents        ;
    try {
      contents = await promisify(readFile)(path);
    } catch (e) {
      this.emit('error', `Could not read file: ${path}`);
      return null;
    }
    try {
      return JSON.parse(contents);
    } catch (e) {
      this.emit('error', `Could not parse file: ${path}`);
      return null;
    }
  }
  async _handleFileChange(evt        , path        )                {
    let result;
    try {
      const cacheObject = await this._readFile(path);
      result = await this._transform(cacheObject);
    } catch (e) {
      this.emit('error', `CacheError: ${e.message}`);
    }
    if (result) {
      this._cache.set(path, result);
      this.emit(evt, path, result);
    }
  }
  async add(path        )                {
    if (this._cache.has(path)) return;
    this._handleFileChange('add', path);
  }
  async change(path        )                {
    if (!this._cache.has(path)) {
      this.emit('error', `Can not change non existing path ${path}`);
      return;
    }
    this._handleFileChange('change', path);
  }
  get(path        )              {
    return this._cache.get(path) || null;
  }
  values()                     {
    return Array.from(this._cache.values());
  }
  close()       {
    this._watcher.close();
  }
  remove(path        )       {
    this._cache.delete(path);
    this.emit('remove', path);
  }
}

module.exports = TrufflePigCache;
