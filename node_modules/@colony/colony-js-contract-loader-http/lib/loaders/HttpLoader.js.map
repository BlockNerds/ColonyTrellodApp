{"version":3,"sources":["../../src/loaders/HttpLoader.js"],"names":["HttpLoader","endpoint","transform","_endpoint","contractName","contractAddress","version","replace","Number","parseInt","toString","query","requiredProps","throwError","action","error","Error","message","response","fetch","resolveEndpointResource","json","contractDef","_transform"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;;;;AACA;;AACA;;;;;;IAWqBA,U;;;AAInB,wBAA2D;AAAA,mFAAJ,EAAI;AAAA,QAA7CC,QAA6C,QAA7CA,QAA6C;AAAA,QAAnCC,SAAmC,QAAnCA,SAAmC;;AAAA;;AAAA,sIACnD,EAAEA,oBAAF,EADmD;;AAEzD,0BACE,OAAOD,QAAP,KAAoB,QAApB,IAAgCA,QADlC,EAEE,uCAFF;AAIA,UAAKE,SAAL,GAAiBF,QAAjB;AANyD;AAO1D;;;;mDAKiB;AAAA,UAHhBG,YAGgB,SAHhBA,YAGgB;AAAA,UAFhBC,eAEgB,SAFhBA,eAEgB;AAAA,UADhBC,OACgB,SADhBA,OACgB;;AAChB,aACE,KAAKH,SAAL,CACGI,OADH,CACW,UADX,EACuBH,gBAAgB,EADvC,EAEGG,OAFH,CAEW,aAFX,EAE0BF,mBAAmB,EAF7C;AAGE;AAHF,OAIGE,OAJH,CAKI,aALJ,EAMID,WAAW,IAAX,KACC,OAAOA,OAAP,KAAmB,QAAnB,IACCE,OAAOC,SAASH,OAAT,EAAkB,EAAlB,CAAP,MAAkCA,OAFpC,IAGIA,QAAQI,QAAR,EAHJ,GAII,EAVR,CADF;AAcD;;;;;YAECC,K,uEAAe,E;YACfC,a;;;;;;AAEA;AACMC,0B,GAAa,SAAbA,UAAa,CAACC,MAAD,EAAiBC,KAAjB,EAAgC;AACjD,wBAAM,IAAIC,KAAJ,gBACSF,MADT,uBACgCH,MAAMP,YAAN,IAClCO,MAAMN,eAD4B,IAElC,EAHE,YAGKU,MAAME,OAAN,IAAiBF,KAHtB,EAAN;AAKD,iB;;AAEGG,wB;;;uBAEeC,MAAM,KAAKC,uBAAL,CAA6BT,KAA7B,CAAN,C;;;AAAjBO,wB;;;;;;;;AAEAL,2BAAW,gBAAX;;;AAGEQ,oB;;8BAEKH,YAAYA,SAASG,I;;;;;;;;uBAAeH,SAASG,IAAT,E;;;;;;AAA3CA,oB;;;;;;;;AAEAR,2BAAW,UAAX;;;AAGES,2B;;AACJ,oBAAI;AACFA,gCAAc,KAAKC,UAAL,CAAgBF,IAAhB,EAAsBV,KAAtB,EAA6BC,aAA7B,CAAd;AACD,iBAFD,CAEE,OAAOG,KAAP,EAAc;AACdF,6BAAW,+BAAX,EAA4CE,KAA5C;AACD;iDACMO,W;;;;;;;;;;;;;;;;;;;;kBAjEUtB,U","file":"HttpLoader.js","sourcesContent":["/* @flow */\n\nimport assert from 'assert';\nimport 'isomorphic-fetch';\nimport ContractLoader from '@colony/colony-js-contract-loader';\n\nimport type {\n  ContractDefinition,\n  IContractLoader,\n  RequiredContractProps,\n  Query,\n} from '@colony/colony-js-contract-loader';\n\nimport type { ConstructorArgs } from '../flowtypes';\n\nexport default class HttpLoader extends ContractLoader\n  implements IContractLoader {\n  _endpoint: string;\n\n  constructor({ endpoint, transform }: ConstructorArgs = {}) {\n    super({ transform });\n    assert(\n      typeof endpoint === 'string' && endpoint,\n      'An `endpoint` option must be provided',\n    );\n    this._endpoint = endpoint;\n  }\n  resolveEndpointResource({\n    contractName,\n    contractAddress,\n    version,\n  }: Query): string {\n    return (\n      this._endpoint\n        .replace('%%NAME%%', contractName || '')\n        .replace('%%ADDRESS%%', contractAddress || '')\n        // `version` can be a string or an integer\n        .replace(\n          '%%VERSION%%',\n          version != null &&\n          (typeof version === 'string' ||\n            Number(parseInt(version, 10)) === version)\n            ? version.toString()\n            : '',\n        )\n    );\n  }\n  async _load(\n    query: Query = {},\n    requiredProps?: RequiredContractProps,\n  ): Promise<?ContractDefinition> {\n    // Provide some context for errors thrown by lower-level functions\n    const throwError = (action: string, error: any) => {\n      throw new Error(\n        `Unable to ${action} for contract ${query.contractName ||\n          query.contractAddress ||\n          ''}: ${error.message || error}`,\n      );\n    };\n\n    let response;\n    try {\n      response = await fetch(this.resolveEndpointResource(query));\n    } catch (error) {\n      throwError('fetch resource', error);\n    }\n\n    let json;\n    try {\n      json = response && response.json && (await response.json());\n    } catch (error) {\n      throwError('get JSON', error);\n    }\n\n    let contractDef;\n    try {\n      contractDef = this._transform(json, query, requiredProps);\n    } catch (error) {\n      throwError('transform contract definition', error);\n    }\n    return contractDef;\n  }\n}\n"]}