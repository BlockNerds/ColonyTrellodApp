{"version":3,"sources":["../src/EthersAdapter.js"],"names":["EthersAdapter","events","timeoutMs","transactionHash","mapEventToPromise","contract","handler","Promise","eventName","addListener","args","resolve","removeListener","Object","getOwnPropertyNames","map","loader","provider","wallet","query","load","abi","address","bytecode","Error","contractParams","Contract","getDeployTransaction","eventPromises","constructor","getEventPromises","assign","all","entries","forEach","getTransactionReceipt","messageHash","messageBytes","utils","arrayify","signMessage","signature","splitSignature","sigR","r","sigS","s","sigV","v","digest","recoveryParam","SigningKey","recover"],"mappings":"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","file":"EthersAdapter.js","sourcesContent":["/* @flow */\n\nimport ethers from 'ethers';\nimport { raceAgainstTimeout } from '@colony/colony-js-utils';\nimport type {\n  IContract,\n  IAdapter,\n  IProvider,\n  IWallet,\n  Event,\n  EventHandler,\n  EventHandlers,\n  Signature,\n  Transaction,\n} from '@colony/colony-js-adapter';\nimport type { Query } from '@colony/colony-js-contract-loader';\n\nimport ContractLoader from '@colony/colony-js-contract-loader';\n\nimport type { ConstructorArgs } from './flowtypes';\nimport EthersContract from './EthersContract';\n\nexport default class EthersAdapter implements IAdapter {\n  loader: ContractLoader;\n  provider: IProvider;\n  wallet: IWallet;\n  static getEventPromises({\n    events,\n    timeoutMs,\n    transactionHash,\n  }: {\n    events: { [eventName: string]: EventHandler },\n    timeoutMs: number,\n    transactionHash: string,\n  }): Array<Promise<any>> {\n    const mapEventToPromise = eventName => {\n      let contract;\n      let handler;\n      return raceAgainstTimeout(\n        new Promise(resolve => {\n          ({ contract, handler } = events[eventName]);\n          contract.addListener(eventName, transactionHash, ({ args }: Event) =>\n            resolve(handler(args)),\n          );\n        }),\n        timeoutMs,\n        () => contract.removeListener(eventName, transactionHash),\n      );\n    };\n    return Object.getOwnPropertyNames(events).map(mapEventToPromise);\n  }\n  constructor({ loader, provider, wallet }: ConstructorArgs) {\n    this.loader = loader;\n    this.provider = provider;\n    this.wallet = wallet;\n  }\n  async getContract(query: Query): Promise<IContract> {\n    const { address, abi } = await this.loader.load(query, {\n      abi: true,\n      address: true,\n      bytecode: false,\n    });\n\n    if (typeof address !== 'string')\n      throw new Error('Unable to parse contract address');\n\n    return new EthersContract(address, abi, this.wallet);\n  }\n  async getContractDeployTransaction(\n    query: Query,\n    contractParams: Array<any>,\n  ): Promise<Transaction> {\n    const { abi, bytecode } = await this.loader.load(query, {\n      abi: true,\n      address: false,\n      bytecode: true,\n    });\n    return ethers.Contract.getDeployTransaction(\n      bytecode,\n      abi,\n      ...contractParams,\n    );\n  }\n  // XXX this isn't a static method because we can't define it as such\n  // in the Interface thanks to Flow\n  async getEventData({\n    events = {},\n    transactionHash,\n    timeoutMs,\n  }: {\n    events: EventHandlers,\n    timeoutMs: number,\n    transactionHash: string,\n  }): Promise<{}> {\n    const eventPromises = this.constructor.getEventPromises({\n      events,\n      timeoutMs,\n      transactionHash,\n    });\n    try {\n      // Wait for all success events to resolve, or reject on any error event\n      return Object.assign({}, ...(await Promise.all(eventPromises)));\n    } finally {\n      Object.entries(events).forEach(([eventName, { contract }]) => {\n        contract.removeListener(eventName, transactionHash);\n      });\n    }\n  }\n  async getTransactionReceipt(transactionHash: string) {\n    return this.provider.getTransactionReceipt(transactionHash);\n  }\n  /**\n   * Sign a message hash (as binary) and return a split signature.\n   */\n  async signMessage(messageHash: string) {\n    const messageBytes = ethers.utils.arrayify(messageHash);\n    const signature = await this.wallet.signMessage(messageBytes);\n\n    const { r: sigR, s: sigS, v: sigV } = ethers.utils.splitSignature(\n      signature,\n    );\n    return {\n      sigR,\n      sigS,\n      sigV,\n    };\n  }\n\n  /**\n   * Given a message digest and a signature, recover the address used to\n   * sign the message.\n   */\n  // eslint-disable-next-line class-methods-use-this\n  ecRecover(digest: Array<number>, { sigR, sigS, sigV }: Signature): string {\n    // This method doesn't need to be static, but flow Interfaces don't\n    // support static methods.\n    const recoveryParam = sigV - 27;\n    return ethers.SigningKey.recover(digest, sigR, sigS, recoveryParam);\n  }\n}\n"]}