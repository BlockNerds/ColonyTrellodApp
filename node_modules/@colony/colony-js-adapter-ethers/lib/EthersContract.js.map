{"version":3,"sources":["../src/EthersContract.js"],"names":["EthersContract","address","abi","wallet","_listeners","Map","_initialiseEvents","functionName","args","fn","functions","TypeError","estimate","options","name","interfaceFn","interface","data","eventName","transactionHash","callback","set","delete","Object","getOwnPropertyNames","events","forEach","self","eventDispatcher","_dispatchEvent","event","key","get","removeListener","Contract"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;;;;;;IAWMA,c;;;AAIJ;;;;;AAKA,0BAAYC,OAAZ,EAA6BC,GAA7B,EAA8CC,MAA9C,EAA+D;AAAA;;AAAA,8IACvDF,OADuD,EAC9CC,GAD8C,EACzCC,MADyC;;AAE7D,UAAKC,UAAL,GAAkB,IAAIC,GAAJ,EAAlB;AACA,UAAKC,iBAAL;AAH6D;AAI9D;;AAED;;;;;AAdA;;;;;;2GAkBmBC,Y,EAAsBC,I;;;;;;AACjCC,kB,GAAK,KAAKC,SAAL,CAAeH,YAAf,C;;sBACP,OAAOE,EAAP,KAAc,U;;;;;sBACV,IAAIE,SAAJ,eAA0BJ,YAA1B,4B;;;iDACDE,qDAAMD,IAAN,E;;;;;;;;;;;;;;;;;AAGT;;;;;;;;6GAImBD,Y,EAAsBC,I;;;;;;AACjCC,kB,GAAK,KAAKG,QAAL,CAAcL,YAAd,C;;sBACP,OAAOE,EAAP,KAAc,U;;;;;sBACV,IAAIE,SAAJ,0BACmBJ,YADnB,4B;;;kDAGDE,qDAAMD,IAAN,E;;;;;;;;;;;;;;;;;AAGT;;;;;;;;6GAKED,Y,EACAC,I,EACAK,O;;;;;;AAEMJ,kB,GAAK,KAAKC,SAAL,CAAeH,YAAf,C;;sBACP,OAAOE,EAAP,KAAc,U;;;;;sBACV,IAAIE,SAAJ,eAA0BJ,YAA1B,4B;;;kDACDE,qDAAMD,IAAN,UAAYK,OAAZ,G;;;;;;;;;;;;;;;;;AAGT;;;;;;;;0CAKsBC,I,EAAcN,I,EAA0B;AAC5D,UAAMO,cAAc,KAAKC,SAAL,CAAeN,SAAf,CAAyBI,IAAzB,CAApB;AACA,UAAI,OAAOC,WAAP,KAAuB,UAA3B,EACE,MAAM,IAAIJ,SAAJ,eAA0BG,IAA1B,sCAAN;;AAH0D,yBAI3CC,8DAAeP,IAAf,EAJ2C;AAAA,UAIpDS,IAJoD,gBAIpDA,IAJoD;;AAK5D,aAAOA,IAAP;AACD;;;gCAEWC,S,EAAmBC,e,EAAyBC,Q,EAAoB;AAC1E,WAAKhB,UAAL,CAAgBiB,GAAhB,CAAuBH,SAAvB,SAAoCC,eAApC,EAAuDC,QAAvD;AACD;;;mCACcF,S,EAAmBC,e,EAAyB;AACzD,WAAKf,UAAL,CAAgBkB,MAAhB,CAA0BJ,SAA1B,SAAuCC,eAAvC;AACD;;;wCACmB;AAAA;;AAClBI,aAAOC,mBAAP,CAA2B,KAAKC,MAAhC,EAAwCC,OAAxC,CAAgD,qBAAa;AAC3D,YAAMC,aAAN;AACA,eAAKF,MAAL,CAAYP,SAAZ,IAAyB,SAASU,eAAT,GAA2B;AAClDD,eAAKE,cAAL,CAAoB,IAApB,EADkD,CACvB;AAC5B,SAFD;AAGD,OALD;AAMD;;;mCACcC,K,EAAc;AAC3B,UAAMC,MAASD,MAAMA,KAAf,SAAwBA,MAAMX,eAApC;AACA,UAAMC,WAAW,KAAKhB,UAAL,CAAgB4B,GAAhB,CAAoBD,GAApB,CAAjB;AACA,UAAIX,QAAJ,EAAc;AACZ,aAAKa,cAAL,CAAoBH,MAAMA,KAA1B,EAAiCA,MAAMX,eAAvC;AACAC,iBAASU,KAAT;AACD;AACF;;;EAxF0B,iBAAOI,Q;;kBA2FrBlC,c","file":"EthersContract.js","sourcesContent":["/* @flow */\n\nimport ethers from 'ethers';\n\nimport type {\n  Event,\n  IContract,\n  IWallet,\n  TransactionOptions,\n} from '@colony/colony-js-adapter';\n\nimport type { EventListenerCallback } from './flowtypes';\n\nclass EthersContract extends ethers.Contract implements IContract {\n  // A map of contract event names to callbacks\n  _listeners: Map<string, EventListenerCallback>;\n\n  /**\n   * EthersContract constructor\n   * Extends `ethers.Contract` with event handling that allows us to\n   * wait for event data and return it as the adapter interface specifies\n   */\n  constructor(address: string, abi: Array<any>, wallet: IWallet) {\n    super(address, abi, wallet);\n    this._listeners = new Map();\n    this._initialiseEvents();\n  }\n\n  /**\n   * Given a function name and an array of arguments, apply the arguments and\n   * return the resulting value/s.\n   */\n  async callConstant(functionName: string, args: Array<any>) {\n    const fn = this.functions[functionName];\n    if (typeof fn !== 'function')\n      throw new TypeError(`Function ${functionName} not found on contract`);\n    return fn(...args);\n  }\n\n  /**\n   * Given a function name and an array of arguments, apply the arguments and\n   * return the resulting gas cost estimate as a BigNumber\n   */\n  async callEstimate(functionName: string, args: Array<any>) {\n    const fn = this.estimate[functionName];\n    if (typeof fn !== 'function')\n      throw new TypeError(\n        `Estimation function ${functionName} not found on contract`,\n      );\n    return fn(...args);\n  }\n\n  /**\n   * Given a function name, an array of arguments and optional transaction\n   * options, apply the arguments and return the sent transaction\n   */\n  async callTransaction(\n    functionName: string,\n    args: Array<any>,\n    options: TransactionOptions,\n  ) {\n    const fn = this.functions[functionName];\n    if (typeof fn !== 'function')\n      throw new TypeError(`Function ${functionName} not found on contract`);\n    return fn(...args, options);\n  }\n\n  /**\n   * Given the name of an interface function, and an array of arguments\n   * that will be accepted byt that function, get the data from the interface\n   * by applying the arguments to it.\n   */\n  createTransactionData(name: string, args: Array<any>): string {\n    const interfaceFn = this.interface.functions[name];\n    if (typeof interfaceFn !== 'function')\n      throw new TypeError(`Function ${name} not found on contract interface`);\n    const { data } = interfaceFn(...args);\n    return data;\n  }\n\n  addListener(eventName: string, transactionHash: string, callback: Function) {\n    this._listeners.set(`${eventName}-${transactionHash}`, callback);\n  }\n  removeListener(eventName: string, transactionHash: string) {\n    this._listeners.delete(`${eventName}-${transactionHash}`);\n  }\n  _initialiseEvents() {\n    Object.getOwnPropertyNames(this.events).forEach(eventName => {\n      const self = this;\n      this.events[eventName] = function eventDispatcher() {\n        self._dispatchEvent(this); // eslint-disable-line no-underscore-dangle\n      };\n    });\n  }\n  _dispatchEvent(event: Event) {\n    const key = `${event.event}-${event.transactionHash}`;\n    const callback = this._listeners.get(key);\n    if (callback) {\n      this.removeListener(event.event, event.transactionHash);\n      callback(event);\n    }\n  }\n}\n\nexport default EthersContract;\n"]}