'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _ethers = require('ethers');

var _ethers2 = _interopRequireDefault(_ethers);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var EthersContract = function (_ethers$Contract) {
  (0, _inherits3.default)(EthersContract, _ethers$Contract);

  /**
   * EthersContract constructor
   * Extends `ethers.Contract` with event handling that allows us to
   * wait for event data and return it as the adapter interface specifies
   */
  function EthersContract(address, abi, wallet) {
    (0, _classCallCheck3.default)(this, EthersContract);

    var _this = (0, _possibleConstructorReturn3.default)(this, (EthersContract.__proto__ || Object.getPrototypeOf(EthersContract)).call(this, address, abi, wallet));

    _this._listeners = new Map();
    _this._initialiseEvents();
    return _this;
  }

  /**
   * Given a function name and an array of arguments, apply the arguments and
   * return the resulting value/s.
   */

  // A map of contract event names to callbacks


  (0, _createClass3.default)(EthersContract, [{
    key: 'callConstant',
    value: function () {
      var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(functionName, args) {
        var fn;
        return _regenerator2.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                fn = this.functions[functionName];

                if (!(typeof fn !== 'function')) {
                  _context.next = 3;
                  break;
                }

                throw new TypeError('Function ' + functionName + ' not found on contract');

              case 3:
                return _context.abrupt('return', fn.apply(undefined, (0, _toConsumableArray3.default)(args)));

              case 4:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function callConstant(_x, _x2) {
        return _ref.apply(this, arguments);
      }

      return callConstant;
    }()

    /**
     * Given a function name and an array of arguments, apply the arguments and
     * return the resulting gas cost estimate as a BigNumber
     */

  }, {
    key: 'callEstimate',
    value: function () {
      var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(functionName, args) {
        var fn;
        return _regenerator2.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                fn = this.estimate[functionName];

                if (!(typeof fn !== 'function')) {
                  _context2.next = 3;
                  break;
                }

                throw new TypeError('Estimation function ' + functionName + ' not found on contract');

              case 3:
                return _context2.abrupt('return', fn.apply(undefined, (0, _toConsumableArray3.default)(args)));

              case 4:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function callEstimate(_x3, _x4) {
        return _ref2.apply(this, arguments);
      }

      return callEstimate;
    }()

    /**
     * Given a function name, an array of arguments and optional transaction
     * options, apply the arguments and return the sent transaction
     */

  }, {
    key: 'callTransaction',
    value: function () {
      var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3(functionName, args, options) {
        var fn;
        return _regenerator2.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                fn = this.functions[functionName];

                if (!(typeof fn !== 'function')) {
                  _context3.next = 3;
                  break;
                }

                throw new TypeError('Function ' + functionName + ' not found on contract');

              case 3:
                return _context3.abrupt('return', fn.apply(undefined, (0, _toConsumableArray3.default)(args).concat([options])));

              case 4:
              case 'end':
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function callTransaction(_x5, _x6, _x7) {
        return _ref3.apply(this, arguments);
      }

      return callTransaction;
    }()

    /**
     * Given the name of an interface function, and an array of arguments
     * that will be accepted byt that function, get the data from the interface
     * by applying the arguments to it.
     */

  }, {
    key: 'createTransactionData',
    value: function createTransactionData(name, args) {
      var interfaceFn = this.interface.functions[name];
      if (typeof interfaceFn !== 'function') throw new TypeError('Function ' + name + ' not found on contract interface');

      var _interfaceFn = interfaceFn.apply(undefined, (0, _toConsumableArray3.default)(args)),
          data = _interfaceFn.data;

      return data;
    }
  }, {
    key: 'addListener',
    value: function addListener(eventName, transactionHash, callback) {
      this._listeners.set(eventName + '-' + transactionHash, callback);
    }
  }, {
    key: 'removeListener',
    value: function removeListener(eventName, transactionHash) {
      this._listeners.delete(eventName + '-' + transactionHash);
    }
  }, {
    key: '_initialiseEvents',
    value: function _initialiseEvents() {
      var _this2 = this;

      Object.getOwnPropertyNames(this.events).forEach(function (eventName) {
        var self = _this2;
        _this2.events[eventName] = function eventDispatcher() {
          self._dispatchEvent(this); // eslint-disable-line no-underscore-dangle
        };
      });
    }
  }, {
    key: '_dispatchEvent',
    value: function _dispatchEvent(event) {
      var key = event.event + '-' + event.transactionHash;
      var callback = this._listeners.get(key);
      if (callback) {
        this.removeListener(event.event, event.transactionHash);
        callback(event);
      }
    }
  }]);
  return EthersContract;
}(_ethers2.default.Contract);

exports.default = EthersContract;
//# sourceMappingURL=EthersContract.js.map