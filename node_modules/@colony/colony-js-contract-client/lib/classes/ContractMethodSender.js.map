{"version":3,"sources":["../../src/classes/ContractMethodSender.js"],"names":["ContractMethodSender","defaultGasLimit","eventHandlers","rest","_defaultGasLimit","inputValues","args","getValidatedArgs","client","estimate","functionName","options","_send","transaction","timeoutMs","adapter","getTransactionReceipt","hash","receipt","meta","successful","status","eventData","getEventData","events","transactionHash","receiptPromise","successfulPromise","Promise","resolve","reject","toString","eventDataPromise","callArgs","_getDefaultSendOptions","waitForMining","transactionOptions","_sendTransaction","_sendWithWaitingForMining","_sendWithoutWaitingForMining","send","Object","assign","gasLimit"],"mappings":"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","file":"ContractMethodSender.js","sourcesContent":["/* @flow */\n\nimport BigNumber from 'bn.js';\nimport { raceAgainstTimeout } from '@colony/colony-js-utils';\n\nimport type {\n  EventHandlers,\n  Transaction,\n  TransactionOptions,\n} from '@colony/colony-js-adapter';\n\nimport ContractClient from './ContractClient';\nimport ContractMethod from './ContractMethod';\nimport type {\n  ContractResponse,\n  ContractMethodArgs,\n  SendOptions,\n} from '../flowtypes';\nimport { DEFAULT_SEND_OPTIONS } from '../defaults';\n\nexport default class ContractMethodSender<\n  InputValues: { [inputValueName: string]: any },\n  OutputValues: { [outputValueName: string]: any },\n  IContractClient: ContractClient,\n> extends ContractMethod<InputValues, OutputValues, IContractClient> {\n  eventHandlers: EventHandlers;\n  _defaultGasLimit: ?number;\n\n  constructor({\n    defaultGasLimit,\n    eventHandlers,\n    ...rest\n  }: ContractMethodArgs<IContractClient> & {\n    eventHandlers?: EventHandlers,\n    defaultGasLimit?: number,\n  }) {\n    super(rest);\n    if (defaultGasLimit) this._defaultGasLimit = defaultGasLimit;\n    if (eventHandlers) this.eventHandlers = eventHandlers;\n  }\n\n  /**\n   * Given named input values, call the method's contract function in\n   * order to get a gas estimate for calling it with those values.\n   */\n  async estimate(inputValues: InputValues): Promise<BigNumber> {\n    const args = this.getValidatedArgs(inputValues);\n    return this.client.estimate(this.functionName, args);\n  }\n\n  /**\n   * Given named input values and options for sending a transaction, create a\n   * transaction which calls the method's contract function with those\n   * values as transformed parameters, and collect the transaction receipt\n   * and (optionally) event data.\n   */\n  async send(\n    inputValues: InputValues,\n    options: SendOptions,\n  ): Promise<ContractResponse<OutputValues>> {\n    const args = this.getValidatedArgs(inputValues);\n    return this._send(args, options);\n  }\n\n  async _sendWithWaitingForMining(\n    transaction: Transaction,\n    timeoutMs: number,\n  ): Promise<ContractResponse<OutputValues>> {\n    const receipt = await raceAgainstTimeout(\n      this.client.adapter.getTransactionReceipt(transaction.hash),\n      timeoutMs,\n    );\n\n    const meta = {\n      transaction,\n      receipt,\n    };\n    const successful = receipt.status === 1;\n\n    // If the receipt wasn't successful, return immediately rather than waiting\n    // for events/mined tx\n    if (!successful) {\n      return {\n        successful,\n        meta,\n        eventData: {},\n      };\n    }\n\n    const eventData = await this.client.getEventData({\n      events: this.eventHandlers,\n      timeoutMs,\n      transactionHash: transaction.hash,\n    });\n\n    return {\n      successful,\n      meta,\n      eventData,\n    };\n  }\n\n  _sendWithoutWaitingForMining(\n    transaction: Transaction,\n    timeoutMs: number,\n  ): ContractResponse<OutputValues> {\n    const receiptPromise = raceAgainstTimeout(\n      this.client.adapter.getTransactionReceipt(transaction.hash),\n      timeoutMs,\n    );\n    const successfulPromise = new Promise(async (resolve, reject) => {\n      try {\n        const { status } = await receiptPromise;\n        resolve(status === 1);\n      } catch (error) {\n        reject(error.toString());\n      }\n    });\n\n    return {\n      successfulPromise,\n      meta: {\n        receiptPromise,\n        transaction,\n      },\n      eventDataPromise: this.client.getEventData({\n        events: this.eventHandlers,\n        timeoutMs,\n        transactionHash: transaction.hash,\n      }),\n    };\n  }\n\n  async _send(\n    callArgs: Array<any>,\n    options: SendOptions,\n  ): Promise<ContractResponse<OutputValues>> {\n    const {\n      timeoutMs,\n      waitForMining,\n      ...transactionOptions\n    } = this._getDefaultSendOptions(options);\n\n    const transaction = await this._sendTransaction(\n      callArgs,\n      transactionOptions,\n    );\n\n    return waitForMining\n      ? this._sendWithWaitingForMining(transaction, timeoutMs)\n      : this._sendWithoutWaitingForMining(transaction, timeoutMs);\n  }\n\n  async _sendTransaction(\n    callArgs: Array<any>,\n    transactionOptions: TransactionOptions,\n  ) {\n    return this.client.send(this.functionName, callArgs, transactionOptions);\n  }\n\n  /**\n   * Given send options, set default values for this Sender.\n   */\n  _getDefaultSendOptions(options: SendOptions) {\n    return Object.assign(\n      {},\n      DEFAULT_SEND_OPTIONS,\n      this._defaultGasLimit ? { gasLimit: this._defaultGasLimit } : {},\n      options,\n    );\n  }\n}\n"]}