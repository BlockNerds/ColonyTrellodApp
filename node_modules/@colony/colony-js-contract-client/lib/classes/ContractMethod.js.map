{"version":3,"sources":["../../src/classes/ContractMethod.js"],"names":["ContractMethod","client","functionName","name","input","output","assertValid","callResult","inputValues","values","concat","length","map","index","type","reduce","acc","value","Object","assign","paramName","paramType","defaultValue","hasOwnProperty","call","args","_parseInputValues","getOwnPropertyNames","console","warn","callArgs","createTransactionData","validate","_getMethodArgs","paramNames","extraParams","keys","filter","includes","join","missingParams","param","every","_validateValue","reason","isValid","error","message","toString","Boolean"],"mappings":"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","file":"ContractMethod.js","sourcesContent":["/* @flow */\n/* eslint-disable no-underscore-dangle */\n\nimport isPlainObject from 'lodash.isplainobject';\nimport { makeAssert } from '@colony/colony-js-utils';\n\nimport type { ContractMethodArgs, Params, Param } from '../flowtypes';\nimport ContractClient from './ContractClient';\nimport {\n  validateValue,\n  convertInputValue,\n  convertOutputValue,\n} from '../modules/paramTypes';\nimport { areParamPairsEmpty, isInputEmpty } from '../modules/inputValidation';\n\n/**\n * Abstract class for interacting with contract methods.\n */\nexport default class ContractMethod<\n  InputValues: { [inputValueName: string]: any },\n  OutputValues: { [outputValueName: string]: any },\n  IContractClient: ContractClient,\n> {\n  assertValid: Function;\n  client: IContractClient;\n  functionName: string;\n  input: Params;\n  name: string;\n  output: Params;\n\n  constructor({\n    client,\n    functionName,\n    name,\n    input,\n    output,\n  }: ContractMethodArgs<IContractClient> = {}) {\n    this.name = name;\n    this.client = client;\n    this.input = input;\n    this.functionName = functionName;\n    this.assertValid = makeAssert(`Validation failed for ${name}`);\n    if (output) this.output = output;\n  }\n\n  /**\n   * Given the result of a contract method call, and the input values used to\n   * make the call, transform these with the expected output parameters in\n   * order to get named output values as the method's `OutputValues`\n   * The inputValues are included for function overloading.\n   */\n  // eslint-disable-next-line no-unused-vars\n  _getOutputValues(callResult: any, inputValues?: InputValues): OutputValues {\n    // It may be a single value or an array; treat it as an array\n    const values = [].concat(callResult);\n\n    // Clean values according to their type and coalesce into an object\n    return this.output && this.output.length\n      ? // $FlowFixMe\n        this.output\n          .map(([name, type], index) => [\n            name,\n            convertOutputValue(values[index], type),\n          ])\n          .reduce(\n            (acc, [name, value]) => Object.assign(acc, { [name]: value }),\n            {},\n          )\n      : callResult;\n  }\n\n  /**\n   * Given input values, map them against the method's expected parameters,\n   * with the appropriate conversion for each type.\n   * Fall back to default values for each parameter.\n   */\n  _parseInputValues(inputValues: InputValues) {\n    return this.input.map(([paramName, paramType, defaultValue]) =>\n      convertInputValue(\n        Object.hasOwnProperty.call(inputValues, paramName)\n          ? inputValues[paramName]\n          : defaultValue,\n        paramType,\n      ),\n    );\n  }\n\n  /**\n   * Given named input values, transform these with the expected parameters\n   * in order to get an array of arguments expected by the contract function.\n   */\n  _getMethodArgs(inputValues?: InputValues): Array<any> {\n    let args = [];\n\n    if (inputValues == null) return args;\n\n    if (this.input && this.input.length) {\n      args = this._parseInputValues(inputValues);\n    } else if (\n      isPlainObject(inputValues) &&\n      Object.getOwnPropertyNames(inputValues).length\n    ) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        'Warning: _getMethodArgs called with parameters for a method that ' +\n          'does not accept parameters',\n      );\n    }\n    return args;\n  }\n\n  /**\n   * Given arguments to call the contract method with, return\n   * transaction data as a hex string.\n   */\n  createTransactionData(callArgs: Array<any>) {\n    return this.client.createTransactionData(this.functionName, callArgs);\n  }\n\n  /**\n   * Given input values, validate them and return parsed method args.\n   */\n  getValidatedArgs(inputValues?: any) {\n    this.validate(inputValues);\n    return this._getMethodArgs(inputValues);\n  }\n\n  /**\n   * Given parameters (as an object with named parameters, but potentially any\n   * kind of invalid input), validate each parameter against the expected type\n   * for this method, throwing vaidation errors or returning true.\n   */\n  validate(input?: any): boolean {\n    if (areParamPairsEmpty(this.input) && isInputEmpty(input)) return true;\n\n    this.assertValid(isPlainObject(input), 'Expected parameters as an object');\n\n    const inputValues = Object.assign({}, input);\n\n    const paramNames = this.input.map(([name]) => name);\n    const extraParams = Object.keys(inputValues).filter(\n      name => !paramNames.includes(name),\n    );\n    this.assertValid(\n      extraParams.length === 0,\n      `Unexpected parameters: \"${extraParams.join(', ')}\"`,\n    );\n\n    // Either the parameter name should exist in the inputValues,\n    // or the parameter should have a default value.\n    const missingParams = this.input.filter(\n      param =>\n        !(\n          Object.hasOwnProperty.call(inputValues, param[0]) ||\n          param.length === 3\n        ),\n    );\n    this.assertValid(\n      missingParams.length === 0,\n      `Missing parameters: \"${missingParams.map(([name]) => name).join(', ')}\"`,\n    );\n\n    return this.input.every(param =>\n      this._validateValue(inputValues[param[0]], param),\n    );\n  }\n\n  _validateValue(value: any, [name, type, defaultValue]: Param) {\n    let reason;\n    let isValid = false;\n    try {\n      isValid = validateValue(\n        typeof value !== 'undefined' ? value : defaultValue,\n        type,\n      );\n    } catch (error) {\n      reason = error.message || error.toString();\n    }\n    return this.assertValid(\n      Boolean(isValid),\n      `Parameter \"${name}\" expected a value of type \"${type}\"${\n        reason ? ` (${reason})` : ''\n      }`,\n    );\n  }\n}\n"]}