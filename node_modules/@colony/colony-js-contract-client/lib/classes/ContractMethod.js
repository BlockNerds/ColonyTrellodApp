'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty2 = require('babel-runtime/helpers/defineProperty');

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _lodash = require('lodash.isplainobject');

var _lodash2 = _interopRequireDefault(_lodash);

var _colonyJsUtils = require('@colony/colony-js-utils');

var _ContractClient = require('./ContractClient');

var _ContractClient2 = _interopRequireDefault(_ContractClient);

var _paramTypes = require('../modules/paramTypes');

var _inputValidation = require('../modules/inputValidation');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Abstract class for interacting with contract methods.
 */
var ContractMethod = function () {
  function ContractMethod() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        client = _ref.client,
        functionName = _ref.functionName,
        name = _ref.name,
        input = _ref.input,
        output = _ref.output;

    (0, _classCallCheck3.default)(this, ContractMethod);

    this.name = name;
    this.client = client;
    this.input = input;
    this.functionName = functionName;
    this.assertValid = (0, _colonyJsUtils.makeAssert)('Validation failed for ' + name);
    if (output) this.output = output;
  }

  /**
   * Given the result of a contract method call, and the input values used to
   * make the call, transform these with the expected output parameters in
   * order to get named output values as the method's `OutputValues`
   * The inputValues are included for function overloading.
   */
  // eslint-disable-next-line no-unused-vars


  (0, _createClass3.default)(ContractMethod, [{
    key: '_getOutputValues',
    value: function _getOutputValues(callResult, inputValues) {
      // It may be a single value or an array; treat it as an array
      var values = [].concat(callResult);

      // Clean values according to their type and coalesce into an object
      return this.output && this.output.length ? // $FlowFixMe
      this.output.map(function (_ref2, index) {
        var _ref3 = (0, _slicedToArray3.default)(_ref2, 2),
            name = _ref3[0],
            type = _ref3[1];

        return [name, (0, _paramTypes.convertOutputValue)(values[index], type)];
      }).reduce(function (acc, _ref4) {
        var _ref5 = (0, _slicedToArray3.default)(_ref4, 2),
            name = _ref5[0],
            value = _ref5[1];

        return Object.assign(acc, (0, _defineProperty3.default)({}, name, value));
      }, {}) : callResult;
    }

    /**
     * Given input values, map them against the method's expected parameters,
     * with the appropriate conversion for each type.
     * Fall back to default values for each parameter.
     */

  }, {
    key: '_parseInputValues',
    value: function _parseInputValues(inputValues) {
      return this.input.map(function (_ref6) {
        var _ref7 = (0, _slicedToArray3.default)(_ref6, 3),
            paramName = _ref7[0],
            paramType = _ref7[1],
            defaultValue = _ref7[2];

        return (0, _paramTypes.convertInputValue)(Object.hasOwnProperty.call(inputValues, paramName) ? inputValues[paramName] : defaultValue, paramType);
      });
    }

    /**
     * Given named input values, transform these with the expected parameters
     * in order to get an array of arguments expected by the contract function.
     */

  }, {
    key: '_getMethodArgs',
    value: function _getMethodArgs(inputValues) {
      var args = [];

      if (inputValues == null) return args;

      if (this.input && this.input.length) {
        args = this._parseInputValues(inputValues);
      } else if ((0, _lodash2.default)(inputValues) && Object.getOwnPropertyNames(inputValues).length) {
        // eslint-disable-next-line no-console
        console.warn('Warning: _getMethodArgs called with parameters for a method that ' + 'does not accept parameters');
      }
      return args;
    }

    /**
     * Given arguments to call the contract method with, return
     * transaction data as a hex string.
     */

  }, {
    key: 'createTransactionData',
    value: function createTransactionData(callArgs) {
      return this.client.createTransactionData(this.functionName, callArgs);
    }

    /**
     * Given input values, validate them and return parsed method args.
     */

  }, {
    key: 'getValidatedArgs',
    value: function getValidatedArgs(inputValues) {
      this.validate(inputValues);
      return this._getMethodArgs(inputValues);
    }

    /**
     * Given parameters (as an object with named parameters, but potentially any
     * kind of invalid input), validate each parameter against the expected type
     * for this method, throwing vaidation errors or returning true.
     */

  }, {
    key: 'validate',
    value: function validate(input) {
      var _this = this;

      if ((0, _inputValidation.areParamPairsEmpty)(this.input) && (0, _inputValidation.isInputEmpty)(input)) return true;

      this.assertValid((0, _lodash2.default)(input), 'Expected parameters as an object');

      var inputValues = Object.assign({}, input);

      var paramNames = this.input.map(function (_ref8) {
        var _ref9 = (0, _slicedToArray3.default)(_ref8, 1),
            name = _ref9[0];

        return name;
      });
      var extraParams = Object.keys(inputValues).filter(function (name) {
        return !paramNames.includes(name);
      });
      this.assertValid(extraParams.length === 0, 'Unexpected parameters: "' + extraParams.join(', ') + '"');

      // Either the parameter name should exist in the inputValues,
      // or the parameter should have a default value.
      var missingParams = this.input.filter(function (param) {
        return !(Object.hasOwnProperty.call(inputValues, param[0]) || param.length === 3);
      });
      this.assertValid(missingParams.length === 0, 'Missing parameters: "' + missingParams.map(function (_ref10) {
        var _ref11 = (0, _slicedToArray3.default)(_ref10, 1),
            name = _ref11[0];

        return name;
      }).join(', ') + '"');

      return this.input.every(function (param) {
        return _this._validateValue(inputValues[param[0]], param);
      });
    }
  }, {
    key: '_validateValue',
    value: function _validateValue(value, _ref12) {
      var _ref13 = (0, _slicedToArray3.default)(_ref12, 3),
          name = _ref13[0],
          type = _ref13[1],
          defaultValue = _ref13[2];

      var reason = void 0;
      var isValid = false;
      try {
        isValid = (0, _paramTypes.validateValue)(typeof value !== 'undefined' ? value : defaultValue, type);
      } catch (error) {
        reason = error.message || error.toString();
      }
      return this.assertValid(Boolean(isValid), 'Parameter "' + name + '" expected a value of type "' + type + '"' + (reason ? ' (' + reason + ')' : ''));
    }
  }]);
  return ContractMethod;
}();
/* eslint-disable no-underscore-dangle */

exports.default = ContractMethod;
//# sourceMappingURL=ContractMethod.js.map