{"version":3,"sources":["../../src/classes/MultisigOperation.js"],"names":["MultisigOperation","payload","assert","data","destinationAddress","sourceAddress","value","Number","signature","sigV","sigR","sigS","mode","includes","Object","values","signers","entries","every","address","_validateSignature","sender","args","nonce","onReset","constructor","_validatePayload","_validateSigners","isInteger","freeze","assign","_signers","_onReset","undefined","_nonce","JSON","stringify","json","parsed","parse","error","Error","TREZOR","_signedTrezorMessageDigest","_signedMessageDigest","foundMode","adapter","client","wallet","forEach","digest","_getMessageDigest","recovered","ecRecover","toLowerCase","combined","keys","sort","push","_combineSignatures","missingSignees","length","join","options","refresh","_validateRequiredSignees","sendMultisig","_getArgs","_findSignatureMode","signMessage","_messageHash","_addSignature","_refreshNonce","_refreshRequiredSignees","_refreshMessageHash","hasOwnProperty","call","getNonce","oldNonce","newNonce","getRequiredSignees","inputValues","_requiredSignees","addresses","slice","paddedValue","toString","paddedNonce","Array","isArray","requiredSignees","filter"],"mappings":"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","file":"MultisigOperation.js","sourcesContent":["/* @flow */\n/* eslint-disable no-underscore-dangle */\n\nimport { padLeft, soliditySha3, isHexStrict, hexToBytes } from 'web3-utils';\nimport defaultAssert from 'assert';\nimport { isValidAddress, makeAssert } from '@colony/colony-js-utils';\nimport isPlainObject from 'lodash.isplainobject';\nimport isEqual from 'lodash.isequal';\n\nimport ContractMethodMultisigSender from './ContractMethodMultisigSender';\nimport ContractClient from './ContractClient';\n\nimport type {\n  CombinedSignatures,\n  MultisigOperationConstructorArgs,\n  MultisigOperationPayload,\n  SendOptions,\n  Signature,\n  Signers,\n  SigningMode,\n} from '../flowtypes';\n\nimport { SIGNING_MODES } from '../constants';\n\nexport default class MultisigOperation<\n  InputValues: { [inputValueName: string]: any },\n  OutputValues: { [outputValueName: string]: any },\n  IContractClient: ContractClient,\n  Sender: ContractMethodMultisigSender<\n    InputValues,\n    OutputValues,\n    IContractClient,\n  >,\n> {\n  sender: Sender;\n  payload: MultisigOperationPayload<InputValues>; // Immutable\n  _messageHash: string;\n  _nonce: number;\n  _onReset: ?Function;\n  _requiredSignees: Array<string>;\n  _signers: Signers;\n\n  static _validatePayload(payload: any) {\n    const assert = makeAssert('Invalid payload');\n\n    assert(isPlainObject(payload), 'Payload must be an object');\n\n    const { data, destinationAddress, sourceAddress, value } = payload || {};\n\n    assert(isHexStrict(data), 'data must be a hex string');\n\n    assert(\n      isValidAddress(destinationAddress),\n      'destinationAddress must be a valid address',\n    );\n\n    assert(\n      isValidAddress(sourceAddress),\n      'sourceAddress must be a valid address',\n    );\n\n    return assert(\n      Number(value) === value && value >= 0,\n      'value must be a positive number',\n    );\n  }\n\n  static _validateSignature(signature: any, assert: Function = defaultAssert) {\n    assert(isPlainObject(signature), 'Signature must be an object');\n\n    const { sigV, sigR, sigS, mode } = signature;\n\n    return (\n      assert([27, 28].includes(sigV), 'v must be 27 or 28') &&\n      assert(isHexStrict(sigR), 'r must be a hex string') &&\n      assert(isHexStrict(sigS), 's must be a hex string') &&\n      assert(\n        Object.values(SIGNING_MODES).includes(mode),\n        'mode must be a valid signing mode',\n      )\n    );\n  }\n\n  static _validateSigners(signers: any) {\n    const assert = makeAssert('Invalid _signers');\n\n    assert(isPlainObject(signers), 'Signers must be an object');\n\n    return Object.entries(signers || {}).every(\n      ([address, signature]) =>\n        assert(\n          isValidAddress(address),\n          `\"${address}\" is not a valid address`,\n        ) && this._validateSignature(signature, assert),\n    );\n  }\n\n  constructor(\n    sender: Sender,\n    args: MultisigOperationConstructorArgs<InputValues>,\n  ) {\n    const { payload, signers = {}, nonce, onReset } = args;\n    this.constructor._validatePayload(payload);\n    this.constructor._validateSigners(signers);\n    defaultAssert(\n      nonce == null || Number.isInteger(nonce),\n      'The optional `nonce` parameter should be an integer',\n    );\n\n    this.sender = sender;\n    this.payload = Object.freeze(Object.assign({}, payload));\n    this._signers = signers;\n    if (onReset) this._onReset = onReset;\n    if (nonce !== undefined && Number(nonce) === nonce) this._nonce = nonce;\n  }\n\n  toJSON() {\n    const { _nonce: nonce, payload, _signers: signers } = this;\n    return JSON.stringify({ nonce, payload, signers });\n  }\n\n  /**\n   * Given the state of an operation as JSON, validate the parsed state and\n   * add in the signers.\n   */\n  addSignersFromJSON(json: string) {\n    let parsed = {};\n    try {\n      parsed = JSON.parse(json);\n    } catch (error) {\n      throw new Error('Unable to add signers: could not parse JSON');\n    }\n    const { payload, signers } = parsed;\n\n    defaultAssert(\n      isEqual(this.payload, payload),\n      'Unable to add state; incompatible payloads',\n    );\n    this.constructor._validateSigners(signers);\n    this._signers = Object.assign({}, this._signers, signers);\n    return this;\n  }\n\n  get requiredSignees() {\n    defaultAssert(\n      Array.isArray(this._requiredSignees),\n      'Required signees not defined; call `.refresh` to refresh signees',\n    );\n\n    return this._requiredSignees;\n  }\n\n  get missingSignees() {\n    // $FlowFixMe https://github.com/facebook/flow/issues/6151\n    return this.requiredSignees.filter(address => !this._signers[address]);\n  }\n\n  get _signedMessageDigest() {\n    return hexToBytes(\n      soliditySha3('\\x19Ethereum Signed Message:\\n32', this._messageHash),\n    );\n  }\n\n  get _signedTrezorMessageDigest() {\n    return hexToBytes(\n      soliditySha3('\\x19Ethereum Signed Message:\\n\\x20', this._messageHash),\n    );\n  }\n\n  _getMessageDigest(mode: SigningMode) {\n    return mode === SIGNING_MODES.TREZOR\n      ? this._signedTrezorMessageDigest\n      : this._signedMessageDigest;\n  }\n\n  /**\n   * Given a signature and the address of the current wallet, determine the\n   * signing mode by trying different digests with `ecRecover` until the\n   * wallet address matches the recovered address.\n   */\n  _findSignatureMode(signature: Signature): SigningMode {\n    let foundMode;\n    const { adapter } = this.sender.client;\n    const { address } = adapter.wallet;\n\n    Object.values(SIGNING_MODES).forEach(mode => {\n      const digest = this._getMessageDigest(mode);\n      const recovered = adapter.ecRecover(digest, signature);\n      if (address.toLowerCase() === recovered.toLowerCase()) foundMode = mode;\n    });\n\n    if (foundMode !== undefined) return foundMode;\n\n    throw new Error(`Unable to confirm signature mode for address ${address}`);\n  }\n\n  /**\n   * Given multiple signers, combine each part of the signatures together.\n   */\n  _combineSignatures(): CombinedSignatures {\n    const combined = { sigV: [], sigR: [], sigS: [], mode: [] };\n\n    // Sort by address so that the order is always the same\n    Object.keys(this._signers)\n      .sort()\n      .forEach(address => {\n        const { sigV, sigR, sigS, mode } = this._signers[address];\n        combined.sigV.push(sigV);\n        combined.sigR.push(sigR);\n        combined.sigS.push(sigS);\n        combined.mode.push(mode);\n      });\n\n    return combined;\n  }\n\n  /**\n   * Given the payload and signatures for this operation, combine the signatures\n   * and return the arguments in the order the contract expects.\n   */\n  _getArgs() {\n    const {\n      payload: { value, data },\n    } = this;\n    const { sigV, sigR, sigS, mode } = this._combineSignatures();\n    return [sigV, sigR, sigS, mode, value, data];\n  }\n\n  /**\n   * Ensure that there are no missing signees (based on the input values for\n   * this operation).\n   */\n  _validateRequiredSignees() {\n    defaultAssert(\n      this.missingSignees.length === 0,\n      `Missing signatures (from addresses ${this.missingSignees.join(', ')})`,\n    );\n    return true;\n  }\n\n  /**\n   * Given send options, ensure that the necessary signees have signed the\n   * operation, then get the arguments and send the transaction.\n   */\n  async send(options: SendOptions) {\n    await this.refresh();\n    this._validateRequiredSignees();\n    return this.sender.sendMultisig(this._getArgs(), options);\n  }\n\n  /**\n   * Given a signature and an address, find the signature mode and\n   * add the address/signature to the signers.\n   */\n  _addSignature(signature: Signature, address: string) {\n    const mode = this._findSignatureMode(signature);\n\n    this._signers = Object.assign({}, this._signers, {\n      [address]: {\n        mode,\n        ...signature,\n      },\n    });\n    return this;\n  }\n\n  /**\n   * Sign the message hash with the current wallet and add the signature.\n   */\n  async sign() {\n    await this.refresh();\n    const { adapter } = this.sender.client;\n    const signature = await adapter.signMessage(this._messageHash);\n    this._addSignature(signature, adapter.wallet.address);\n    return this;\n  }\n\n  /**\n   * Refresh the required signees, nonce value and message hash.\n   * If the nonce value has changed, `_signers` will be reset.\n   */\n  async refresh() {\n    await this._refreshNonce();\n    await this._refreshRequiredSignees();\n    this._refreshMessageHash();\n    return this;\n  }\n\n  async _refreshNonce() {\n    // If the nonce has not yet been set, simply set it; Don't reset signers,\n    // because we don't have a way of knowing whether they're valid or nor;\n    // assume they are still valid.\n    if (!Object.hasOwnProperty.call(this, '_nonce')) {\n      this._nonce = await this.sender.getNonce();\n      return;\n    }\n\n    const oldNonce = Number(this._nonce);\n    const newNonce = await this.sender.getNonce();\n    if (oldNonce !== newNonce) {\n      this._nonce = newNonce;\n      // If the nonce changed, the signers are no longer valid\n      this._signers = {};\n      // We will also trigger onReset, if it exists\n      if (this._onReset) this._onReset();\n    }\n  }\n\n  async _refreshRequiredSignees() {\n    this._requiredSignees = await this.sender.getRequiredSignees(\n      this.payload.inputValues,\n    );\n  }\n\n  /**\n   * Given the payload and nonce, use this input to create an ERC191-compatible\n   * message hash\n   */\n  _refreshMessageHash() {\n    const {\n      payload: { data, destinationAddress, sourceAddress, value },\n      _nonce,\n    } = this;\n\n    // Follows ERC191 signature scheme: https://github.com/ethereum/EIPs/issues/191\n    const addresses = `${sourceAddress.slice(2)}${destinationAddress.slice(2)}`;\n    const paddedValue = padLeft(value.toString(16), 64, '0');\n    const paddedNonce = padLeft(_nonce.toString(16), 64, '0');\n    this._messageHash = soliditySha3(\n      `0x${addresses}${paddedValue}${data.slice(2)}${paddedNonce}`,\n    );\n  }\n}\n"]}