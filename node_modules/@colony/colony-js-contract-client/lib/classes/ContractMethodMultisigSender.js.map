{"version":3,"sources":["../../src/classes/ContractMethodMultisigSender.js"],"names":["ContractMethodMultisigSender","client","eventHandlers","functionName","input","name","getRequiredSignees","multisigFunctionName","nonceFunctionName","output","_getRequiredSignees","args","op","refresh","inputValues","signees","Array","isArray","every","call","response","nonce","toNumber","Number","isInteger","options","Error","_send","getValidatedArgs","data","createTransactionData","_startOperation","payload","destinationAddress","contract","address","sourceAddress","value","json","parsed","JSON","parse","callArgs","transactionOptions","send"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;;;;AACA;;AAGA;;;;AACA;;;;AACA;;;;;;IASqBA,4B;;;AASnB;;;;;;;;;;AAUA,8CAUsD;AAAA,QATpDC,MASoD,QATpDA,MASoD;AAAA,QARpDC,aAQoD,QARpDA,aAQoD;AAAA,QAPpDC,YAOoD,QAPpDA,YAOoD;AAAA,QANpDC,KAMoD,QANpDA,KAMoD;AAAA,QALpDC,IAKoD,QALpDA,IAKoD;AAAA,QAJpDC,kBAIoD,QAJpDA,kBAIoD;AAAA,QAHpDC,oBAGoD,QAHpDA,oBAGoD;AAAA,QAFpDC,iBAEoD,QAFpDA,iBAEoD;AAAA,QADpDC,MACoD,QADpDA,MACoD;AAAA;;AAAA,0KAC9C,EAAER,cAAF,EAAUI,UAAV,EAAgBI,cAAhB,EAAwBL,YAAxB,EAA+BF,4BAA/B,EAA8CC,0BAA9C,EAD8C;;AAEpD,UAAKO,mBAAL,GAA2BJ,kBAA3B;AACA,UAAKC,oBAAL,GAA4BA,oBAA5B;AACA,UAAKC,iBAAL,GAAyBA,iBAAzB;AAJoD;AAKrD;;AAED;;;;;;;;;4GAIsBG,I;;;;;;AACpB;AACMC,kB,GAAK,gCAAsB,IAAtB,EAA4BD,IAA5B,C;;uBAELC,GAAGC,OAAH,E;;;iDACCD,E;;;;;;;;;;;;;;;;;;;6GAGgBE,W;;;;;;;uBACD,KAAKJ,mBAAL,CAAyBI,WAAzB,C;;;AAAhBC,uB;;AACN,sCACEC,MAAMC,OAAN,CAAcF,OAAd,KAA0BA,QAAQG,KAAR,+BAD5B,EAEE,uCAFF;kDAIOH,O;;;;;;;;;;;;;;;;;AAGT;AACA;;;;;;;;;;;;uBAEyB,KAAKd,MAAL,CAAYkB,IAAZ,CAAiB,KAAKX,iBAAtB,EAAyC,EAAzC,C;;;AAAjBY,wB;AAEAC,qB,GAAQ,gCAAYD,QAAZ,IAAwBA,SAASE,QAAT,EAAxB,GAA8CF,Q;;AAC5D,sCACEG,OAAOF,KAAP,MAAkBA,KAAlB,IAA2BE,OAAOC,SAAP,CAAiBH,KAAjB,CAD7B,EAEE,0BAFF;;kDAKOA,K;;;;;;;;;;;;;;;;AAET;;;;;6GACWP,W,EAA0BW,O;;;;;sBAC7B,IAAIC,KAAJ,CACJ,yDACE,wDAFE,C;;;;;;;;;;;;;;;;;AAMR;;;;;;;6GAGmBf,I,EAAkBc,O;;;;;kDAC5B,KAAKE,KAAL,CAAWhB,IAAX,EAAiBc,OAAjB,C;;;;;;;;;;;;;;;;;AAGT;;;;;;;;6GAIqBX,W;;;;;;AACbH,oB,GAAO,KAAKiB,gBAAL,CAAsBd,WAAtB,C;AACPe,oB,GAAO,KAAK5B,MAAL,CAAY6B,qBAAZ,CAAkC,KAAK3B,YAAvC,EAAqDQ,IAArD,C;kDAEN,KAAKoB,eAAL,CAAqB;AAC1BC,2BAAS;AACPH,8BADO;AAEPf,4CAFO;AAGPmB,wCAAoB,KAAKhC,MAAL,CAAYiC,QAAZ,CAAqBC,OAHlC;AAIPC,mCAAe,KAAKnC,MAAL,CAAYiC,QAAZ,CAAqBC,OAJ7B;AAKPE,2BAAO;AALA;AADiB,iBAArB,C;;;;;;;;;;;;;;;;;AAWT;;;;;;;6GAGuBC,I;;;;;;AACjBC,sB,GAAS,E;;;AAEXA,yBAASC,KAAKC,KAAL,CAAWH,IAAX,CAAT;;;;;;;sBAEM,IAAIZ,KAAJ,CAAU,mDAAV,C;;;kDAED,KAAKK,eAAL,CAAqBQ,MAArB,C;;;;;;;;;;;;;;;;;AAGT;;;;;;;6GAIEG,Q,EACAC,kB;;;;;kDAEO,KAAK1C,MAAL,CAAY2C,IAAZ,CACL,KAAKrC,oBADA,EAELmC,QAFK,EAGLC,kBAHK,C;;;;;;;;;;;;;;;;;;;;kBA5HU3C,4B","file":"ContractMethodMultisigSender.js","sourcesContent":["/* @flow */\n\nimport assert from 'assert';\nimport { isBigNumber, isValidAddress } from '@colony/colony-js-utils';\nimport type { TransactionOptions } from '@colony/colony-js-adapter';\n\nimport ContractClient from './ContractClient';\nimport ContractMethodSender from './ContractMethodSender';\nimport MultisigOperation from './MultisigOperation';\n\nimport type {\n  ContractMethodMultisigSenderArgs,\n  GetRequiredSignees,\n  MultisigOperationConstructorArgs,\n  SendOptions,\n} from '../flowtypes';\n\nexport default class ContractMethodMultisigSender<\n  InputValues: { [outputValueName: string]: any },\n  OutputValues: { [outputValueName: string]: any },\n  IContractClient: ContractClient,\n> extends ContractMethodSender<InputValues, OutputValues, IContractClient> {\n  nonceFunctionName: string;\n  multisigFunctionName: string;\n  _getRequiredSignees: GetRequiredSignees;\n\n  /**\n   * {string} functionName - The contract function name to use for\n   * creating the transaction data\n   * nonceFunctionName - The contract function name to use for\n   * getting the transaction nonce value\n   * getRequiredSignees - Async function that returns the addresses of\n   * the signers (needed to send the transaction)\n   * multisigFunctionName - The contract function name to use for\n   * sending the finalized transaction (with multisig support)\n   */\n  constructor({\n    client,\n    eventHandlers,\n    functionName,\n    input,\n    name,\n    getRequiredSignees,\n    multisigFunctionName,\n    nonceFunctionName,\n    output,\n  }: ContractMethodMultisigSenderArgs<IContractClient>) {\n    super({ client, name, output, input, eventHandlers, functionName });\n    this._getRequiredSignees = getRequiredSignees;\n    this.multisigFunctionName = multisigFunctionName;\n    this.nonceFunctionName = nonceFunctionName;\n  }\n\n  /**\n   * Given a payload and optional signers, start a new MultisigOperation and\n   * refresh it (in order to set the required signees/nonce/etc).\n   */\n  async _startOperation(args: MultisigOperationConstructorArgs<InputValues>) {\n    // Will throw an error if the payload, signers or nonce are deemed invalid.\n    const op = new MultisigOperation(this, args);\n\n    await op.refresh();\n    return op;\n  }\n\n  async getRequiredSignees(inputValues: InputValues): Promise<Array<string>> {\n    const signees = await this._getRequiredSignees(inputValues);\n    assert(\n      Array.isArray(signees) && signees.every(isValidAddress),\n      'Expected an array of signee addresses',\n    );\n    return signees;\n  }\n\n  // XXX After https://github.com/JoinColony/colonyNetwork/issues/192 is\n  // fixed, the inputValues should be accepted by this method.\n  async getNonce(): Promise<number> {\n    const response = await this.client.call(this.nonceFunctionName, []);\n\n    const nonce = isBigNumber(response) ? response.toNumber() : response;\n    assert(\n      Number(nonce) === nonce && Number.isInteger(nonce),\n      'Nonce must be an integer',\n    );\n\n    return nonce;\n  }\n  // eslint-disable-next-line class-methods-use-this,no-unused-vars\n  async send(inputValues: InputValues, options: SendOptions) {\n    throw new Error(\n      'This Sender uses multi-signature transactions; call ' +\n        '`.startOperation()` to start a new `MultisigOperation`',\n    );\n  }\n\n  /**\n   * Given arguments and options for a multisig function, send a transaction.\n   */\n  async sendMultisig(args: Array<any>, options: SendOptions) {\n    return this._send(args, options);\n  }\n\n  /**\n   * Given input values for the target contract method, create transaction data,\n   * and pass the payload into a new MultisigOperation.\n   */\n  async startOperation(inputValues: InputValues) {\n    const args = this.getValidatedArgs(inputValues);\n    const data = this.client.createTransactionData(this.functionName, args);\n\n    return this._startOperation({\n      payload: {\n        data,\n        inputValues,\n        destinationAddress: this.client.contract.address,\n        sourceAddress: this.client.contract.address,\n        value: 0,\n      },\n    });\n  }\n\n  /**\n   * Given the state of an operation as JSON, restore a MultisigOperation.\n   */\n  async restoreOperation(json: string) {\n    let parsed = {};\n    try {\n      parsed = JSON.parse(json);\n    } catch (error) {\n      throw new Error('Unable to restore operation: could not parse JSON');\n    }\n    return this._startOperation(parsed);\n  }\n\n  /**\n   * Override the method from the parent class; use `multisigFunctionName`.\n   */\n  async _sendTransaction(\n    callArgs: Array<any>,\n    transactionOptions: TransactionOptions,\n  ) {\n    return this.client.send(\n      this.multisigFunctionName,\n      callArgs,\n      transactionOptions,\n    );\n  }\n}\n"]}