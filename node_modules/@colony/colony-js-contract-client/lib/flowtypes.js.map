{"version":3,"sources":["../src/flowtypes.js"],"names":[],"mappings":";;AAcA;;;;AACA","file":"flowtypes.js","sourcesContent":["/* @flow */\n\nimport type BigNumber from 'bn.js';\n\nimport type {\n  EventHandlers,\n  IAdapter,\n  Transaction,\n  TransactionOptions,\n  TransactionReceipt,\n} from '@colony/colony-js-adapter';\n\nimport type { Query } from '@colony/colony-js-contract-loader';\n\nimport ContractClient from './classes/ContractClient';\nimport { SIGNING_MODES } from './constants';\n\nexport type ParamTypes =\n  | 'address'\n  | 'bigNumber'\n  | 'boolean'\n  | 'date'\n  | 'ipfsHash'\n  | 'number'\n  | 'string';\n\n// [param name, param type, default value (optional)]\nexport type Param = [string, ParamTypes, *];\n\nexport type Params = Array<Param>;\n\nexport type ParamTypeDef = {\n  validate: (value: any) => boolean,\n  convertOutput: (value: any) => *,\n  convertInput: (value: any) => *,\n};\n\nexport type SendOptions = {\n  estimate: boolean,\n  timeoutMs: number,\n  waitForMining: boolean,\n} & TransactionOptions;\n\nexport type ContractResponseMeta = {\n  transaction: Transaction,\n  receipt?: TransactionReceipt,\n  receiptPromise?: Promise<TransactionReceipt>,\n};\n\nexport type ContractResponse<EventData> = {\n  successful?: boolean,\n  successfulPromise?: Promise<boolean>,\n  eventData?: EventData | {},\n  eventDataPromise?: Promise<EventData | {}>,\n  meta: ContractResponseMeta,\n};\n\nexport type ContractClientConstructorArgs = {\n  adapter: IAdapter,\n  query: Query,\n};\n\nexport type ValidateEmpty = (\n  outputValues: Object | null,\n  inputValues: Object | null,\n) => Promise<boolean>;\n\nexport type ContractMethodArgs<IContractClient: ContractClient> = {\n  client: IContractClient,\n  functionName: string,\n  name: string,\n  input: Params,\n  output?: Params,\n  validateEmpty?: ValidateEmpty,\n};\n\nexport type ContractMethodSenderArgs<IContractClient: ContractClient> = {\n  defaultGasLimit?: BigNumber,\n  eventHandlers?: EventHandlers,\n} & ContractMethodArgs<IContractClient>;\n\nexport type GetRequiredSignees = (input: any) => Promise<Array<string>>;\n\nexport type ContractMethodMultisigSenderArgs<\n  IContractClient: ContractClient,\n> = {\n  nonceFunctionName: string,\n  multisigFunctionName: string,\n  getRequiredSignees: GetRequiredSignees,\n} & ContractMethodSenderArgs<IContractClient>;\n\nexport type ContractMethodDef<IContractClient: ContractClient> = {\n  client: IContractClient,\n  functionName?: string,\n  input: Params,\n  output?: Params,\n};\n\nexport type SigningMode = $Values<typeof SIGNING_MODES>;\n\nexport type Signature = {\n  sigR: string,\n  sigS: string,\n  sigV: number,\n};\n\nexport type Signers = {\n  [signeeAddress: string]: Signature & { mode: SigningMode },\n};\n\nexport type CombinedSignatures = {\n  sigR: Array<string>,\n  sigS: Array<string>,\n  sigV: Array<number>,\n  mode: Array<SigningMode>,\n};\n\nexport type MultisigOperationPayload<InputValues> = {\n  data: string,\n  destinationAddress: string,\n  inputValues: InputValues,\n  sourceAddress: string,\n  value: number,\n};\n\nexport type MultisigOperationConstructorArgs<InputValues> = {\n  payload: MultisigOperationPayload<InputValues>,\n  signers?: Signers,\n  nonce?: number,\n  onReset?: Function,\n};\n"]}