'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.convertInputValue = exports.convertOutputValue = exports.validateValue = undefined;

var _defineProperty2 = require('babel-runtime/helpers/defineProperty');

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

exports.addParamType = addParamType;

var _bs = require('bs58');

var _bs2 = _interopRequireDefault(_bs);

var _bn = require('bn.js');

var _bn2 = _interopRequireDefault(_bn);

var _web3Utils = require('web3-utils');

var _colonyJsUtils = require('@colony/colony-js-utils');

var _inputValidation = require('./inputValidation');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var passThrough = function passThrough(value) {
  return value;
};

/**
 * A map of ParamTypes to ParamTypeDefs
 * For each ParamType (e.g. address), defines how a value should be validated
 * or converted for input/output.
 */


var PARAM_TYPE_MAP = {
  address: {
    validate: _colonyJsUtils.isValidAddress,
    convertOutput: function convertOutput(value) {
      return (0, _colonyJsUtils.isValidAddress)(value) ? value : null;
    },

    convertInput: passThrough
  },
  bigNumber: {
    validate: _colonyJsUtils.isBigNumber,
    convertOutput: function convertOutput(value) {
      if ((0, _colonyJsUtils.isBigNumber)(value)) {
        return value;
      } else if (Number.isFinite(value)) {
        return new _bn2.default(value);
      }
      return null;
    },

    convertInput: passThrough
  },
  boolean: {
    validate: _inputValidation.isBoolean,
    convertOutput: function convertOutput(value) {
      return (0, _inputValidation.isBoolean)(value) ? value : null;
    },

    convertInput: passThrough
  },
  date: {
    validate: function validate(value) {
      return value instanceof Date && !!value.valueOf();
    },
    convertOutput: function convertOutput(value) {
      var converted = parseInt((0, _colonyJsUtils.isBigNumber)(value) ? value.toNumber() : value, 10);
      // Recreate the date by adding milliseconds to the timestamp
      return converted > 0 ? new Date(converted * 1000) : null;
    },
    convertInput: function convertInput(value) {
      // Dates are stored as timestamps without milliseconds
      return parseInt(value.setMilliseconds(0) / 1000, 10);
    }
  },
  number: {
    validate: function validate(value) {
      return Boolean(Number.isFinite(value));
    },
    convertOutput: function convertOutput(value) {
      var converted = (0, _colonyJsUtils.isBigNumber)(value) ? value.toNumber() : value;
      return Number.isFinite(converted) ? converted : null;
    },

    convertInput: passThrough
  },
  string: {
    validate: function validate(value) {
      return typeof value === 'string';
    },
    convertOutput: function convertOutput(value) {
      return typeof value === 'string' && value.length ? value : null;
    },
    convertInput: function convertInput(value) {
      // String values are converted to hex (if they aren't hex already)
      return (0, _web3Utils.isHex)(value) ? value : (0, _web3Utils.utf8ToHex)(value);
    }
  },
  ipfsHash: {
    validate: function validate(value) {
      return typeof value === 'string' && value.slice(0, 2) === 'Qm' && value.length === 46;
    },
    convertOutput: function convertOutput(value) {
      if ((0, _web3Utils.isHex)(value) && !(0, _colonyJsUtils.isEmptyHexString)(value)) {
        var hex = '0x1220' + value.slice(2);
        var bytes = (0, _web3Utils.hexToBytes)(hex);
        return _bs2.default.encode(bytes);
      }
      return null;
    },
    convertInput: function convertInput(value) {
      return '0x' + _bs2.default.decode(value).slice(2).toString('hex');
    }
  }
};

/**
 * Given the key of a ParamTypeDef (namely `validate`, `convertOutput` or
 * `convertInput`), a value and ParamType, pluck the appropriate function
 * from the type map and call it with the value.
 */
function typeMapFn(fnName, value, type) {
  var fn = PARAM_TYPE_MAP[type][fnName];

  return fn(value);
}

function addParamType(type, def) {
  Object.assign(PARAM_TYPE_MAP, (0, _defineProperty3.default)({}, type, def));
}

/**
 * Given a value and a ParamType, validate the value according to that type's
 * `validate` function
 */
var validateValue = exports.validateValue = typeMapFn.bind(undefined, 'validate');

/**
 * Given a value and a ParamType, convert the value according to that type's
 * `convertOutput` function
 */
var convertOutputValue = exports.convertOutputValue = typeMapFn.bind(undefined, 'convertOutput');

/**
 * Given a value and a ParamType, convert the value according to that type's
 * `convertInput` function
 */
var convertInputValue = exports.convertInputValue = typeMapFn.bind(undefined, 'convertInput');
//# sourceMappingURL=paramTypes.js.map