{"version":3,"sources":["../../src/modules/paramTypes.js"],"names":["addParamType","passThrough","value","PARAM_TYPE_MAP","address","validate","convertOutput","convertInput","bigNumber","Number","isFinite","boolean","date","Date","valueOf","converted","parseInt","toNumber","setMilliseconds","number","Boolean","string","length","ipfsHash","slice","hex","bytes","encode","decode","toString","typeMapFn","fnName","type","fn","def","Object","assign","validateValue","bind","convertOutputValue","convertInputValue"],"mappings":"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","file":"paramTypes.js","sourcesContent":["/* @flow */\n\nimport bs58 from 'bs58';\nimport BigNumber from 'bn.js';\nimport { isHex, utf8ToHex, hexToBytes } from 'web3-utils';\nimport {\n  isValidAddress,\n  isBigNumber,\n  isEmptyHexString,\n} from '@colony/colony-js-utils';\n\nimport type { ParamTypes, ParamTypeDef } from '../flowtypes';\nimport { isBoolean } from './inputValidation';\n\nconst passThrough = value => value;\n\n/**\n * A map of ParamTypes to ParamTypeDefs\n * For each ParamType (e.g. address), defines how a value should be validated\n * or converted for input/output.\n */\nconst PARAM_TYPE_MAP: {\n  [type: ParamTypes]: ParamTypeDef,\n} = {\n  address: {\n    validate: isValidAddress,\n    convertOutput(value) {\n      return isValidAddress(value) ? value : null;\n    },\n    convertInput: passThrough,\n  },\n  bigNumber: {\n    validate: isBigNumber,\n    convertOutput(value: any) {\n      if (isBigNumber(value)) {\n        return value;\n      } else if (Number.isFinite(value)) {\n        return new BigNumber(value);\n      }\n      return null;\n    },\n    convertInput: passThrough,\n  },\n  boolean: {\n    validate: isBoolean,\n    convertOutput(value) {\n      return isBoolean(value) ? value : null;\n    },\n    convertInput: passThrough,\n  },\n  date: {\n    validate(value: any) {\n      return value instanceof Date && !!value.valueOf();\n    },\n    convertOutput(value: any) {\n      const converted = parseInt(\n        isBigNumber(value) ? value.toNumber() : value,\n        10,\n      );\n      // Recreate the date by adding milliseconds to the timestamp\n      return converted > 0 ? new Date(converted * 1000) : null;\n    },\n    convertInput(value: Date) {\n      // Dates are stored as timestamps without milliseconds\n      return parseInt(value.setMilliseconds(0) / 1000, 10);\n    },\n  },\n  number: {\n    validate(value: any) {\n      return Boolean(Number.isFinite(value));\n    },\n    convertOutput(value: any) {\n      const converted = isBigNumber(value) ? value.toNumber() : value;\n      return Number.isFinite(converted) ? converted : null;\n    },\n    convertInput: passThrough,\n  },\n  string: {\n    validate(value: any) {\n      return typeof value === 'string';\n    },\n    convertOutput(value: any) {\n      return typeof value === 'string' && value.length ? value : null;\n    },\n    convertInput(value: string) {\n      // String values are converted to hex (if they aren't hex already)\n      return isHex(value) ? value : utf8ToHex(value);\n    },\n  },\n  ipfsHash: {\n    validate(value: any) {\n      return (\n        typeof value === 'string' &&\n        value.slice(0, 2) === 'Qm' &&\n        value.length === 46\n      );\n    },\n    convertOutput(value: any) {\n      if (isHex(value) && !isEmptyHexString(value)) {\n        const hex = `0x1220${value.slice(2)}`;\n        const bytes = hexToBytes(hex);\n        return bs58.encode(bytes);\n      }\n      return null;\n    },\n    convertInput(value: string) {\n      return `0x${bs58\n        .decode(value)\n        .slice(2)\n        .toString('hex')}`;\n    },\n  },\n};\n\n/**\n * Given the key of a ParamTypeDef (namely `validate`, `convertOutput` or\n * `convertInput`), a value and ParamType, pluck the appropriate function\n * from the type map and call it with the value.\n */\nfunction typeMapFn(fnName: $Keys<ParamTypeDef>, value: any, type: ParamTypes) {\n  const {\n    [type]: { [fnName]: fn },\n  } = PARAM_TYPE_MAP;\n  return fn(value);\n}\n\nexport function addParamType(type: string, def: ParamTypeDef): void {\n  Object.assign(PARAM_TYPE_MAP, { [type]: def });\n}\n\n/**\n * Given a value and a ParamType, validate the value according to that type's\n * `validate` function\n */\nexport const validateValue = typeMapFn.bind(this, 'validate');\n\n/**\n * Given a value and a ParamType, convert the value according to that type's\n * `convertOutput` function\n */\nexport const convertOutputValue = typeMapFn.bind(this, 'convertOutput');\n\n/**\n * Given a value and a ParamType, convert the value according to that type's\n * `convertInput` function\n */\nexport const convertInputValue = typeMapFn.bind(this, 'convertInput');\n"]}